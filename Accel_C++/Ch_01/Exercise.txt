1.0
Your_name.cpp 실행 및 컴파일로 대체.

1.1
std::string 타입의 상수 hello를 선언하는 과정에서 초기값을 Hello로 설정하고,
동 타입의 상수 message를 선언하는 과정에서 초기값을 설정할 때 왼쪽 우선 결합성에 의해,
string형 상수 hello와 문자열 리터럴 ", World"가 결합된 임시 문자열에 더해 문자 '!'가 결합되어
message를 선언하는 것이다.
기선언된 string형 상수 hello의 값을 조작하지는 않았으므로 두 상수의 정의문은 올바르다고 할 수 있다.
따라서 문제없이 컴파일되고, 실행도 잘 된다.

1.2
std::string 타입의 상수 exclam을 선언하는 과정에서 초기값을 "!"로 설정하고, 동 타입의 상수 message를
선언하는 과정에서 초기값을 설정할 때 왼쪽 우선 결합성에 의해, 문자열 리터럴 "Hello" 와 ", World"의
결합이 일어나게 되는데, C++에서 문자열 리터럴간의 +연산자를 통한 결합은 지원하지 않으므로
오류가 발생한다. 따라서 정의문에 오류가 있다.

1.3
올바르게 동작한다. 첫 번째 std::string형 상수 s의 유효성은 해당 상수의 선언문과 그 밑의 출력문을
감싸는 중괄호에 한정되며, 중괄호가 끝난 시점부터는 소멸한다. 따라서 두 번째 string형 상수 s는 문제없이
초기화 및 선언, 출력된다.

1.4
중괄호에 의해 첫 번째 선언된 상수 s와 두 번째 선언된 상수 s의 유효성이 명확히 구분되므로 잘 실행된다.
끝에서 세 번째 }}를 };}로 바꿔도 두 상수의 유효성은 변화가 없으므로 잘 실행된다.

1.5
동작하지 않는다. 동작시키려면 세 번째 중괄호를 string형 변수 x의 출력문까지 감싸도록 작성하거나,
아니면 간단히 s의 출력문과 x의 출력문의 위치를 바꾸면 되겠다.

1.6
cin(Console in)을 통해 변수 name에 입력값을 저장할 때, 문자열 리터럴의 입력 종료 기준이 되는 것은
공백문자 또는 EOF이다. 문제에서 제시한 "Samuel Beckett"이라는 문자열 리터럴에 공백문자가 포함되어
있으므로, 프프로그램은 첫 번째 cin 입력문을 통해 "Samuel"을 입력받아 name에 저장하고, 
첫 번째 출력문에 따라"Hello, Samuel"을 출력하고 개행한 뒤 "And what is yours?"를 출력하고,
첫 번째 입력문에서 입력받았던 리터럴의 나머지 부분인 Beckett을 입력받아 name에 저장한다.
그리고 변화된 name의 값을 반영하여 "Hello, Beckett; nice to meet you too!"를 출력하고 개행한 뒤
프로그램을 종료하게 된다.
